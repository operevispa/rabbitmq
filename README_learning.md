# Изучение RabbitMQ
*!Данный файл формировался мною исключительно как конспект для себя же в процессе изучения RabbitMQ и не подлежит проверке преподавателем.*


Для примера работы с брокером очередей мы возьмём интеграцию RabbitMQ и Docker. Для подключения наших процессов к очереди будем использовать библиотеку `pika`. 

RabbitMQ использует протокол AMQP (Advanced Message Queuing Protocol).

Основная терминология AMQP:

- Message (сообщение) — передаваемые данные.
- Exchange (точка обмена) — механизм маршрутизации сообщений. Точка обмена получает сообщения и распределяет их по очередям (одно сообщение может уйти в одну или несколько очередей), но при этом сама она не хранит сообщения. В самом простом случае для маршрутизации сообщений используется ключ (routing key), равный названию очереди, в которую нужно отправить сообщение. Иными словами, routing key — это виртуальный адрес очереди.
- Bindings (правила распределения) — правила, по которым точка обмена определяет, куда именно нужно отправить пришедшее сообщение.
- Queue (очередь) — хранит сообщения до тех пор, пока какой-нибудь AMQP-клиент не заберёт их.
- Producer (издатель) — клиент, публикующий сообщения в exchange.
- Consumer (подписчик) — клиент, получающий сообщения из очередей.
- Connection (соединение) — служит для физического сетевого соединения между клиентом и брокером и объединения нескольких каналов.
- Channel (канал) — используется для логического соединения между клиентом и брокером.


## Описание задачи
Реализуем несколько сервисов:
- Сервис 1 (features.py): Первый будет отправлять признаки в одну очередь и истинный ответ — в другую.
- Сервис 2: Второй сервис будет читать признаки, делать предсказание и отправлять его в очередь с предсказаниями.
- Сервис 3: Третий сервис будет читать очереди с истинными ответами и предсказаниями.


## Запуск готового докеробраза
```bash
docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management
```
Здесь:
- `-p 5672:5672` — порт для доступа к очереди;
- `-p 15672:15672` — порт для доступа к пользовательскому интерфейсу RabbitMQ.
Наша очередь работает и готова к приёму сообщений — к ней можно обратиться по адресу `localhost:5672`.

Для входа в режим графического интерфейса управления RabbitMQ нужно перейди по адресу `http://localhost:15672`. В результате откроется окно графического интерфейса RabbitMQ, с помощью которого можно управлять очередями и другими компонентами RabbitMQ.

## Установка бибилотек
Установка библиотеки pika, которая позволяет подключаться к брокеру сообщений
```bash
pip install pika
```

### Основные команды сервисов
```python
# Подключение к серверу на локальном хосте:
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
```
Если необходимо подключиться к удалённому серверу с брокером, то вместо localhost указываем его IP-адрес.

Объявим в канале соединения очередь сообщений с помощью метода queue_declare(). Назовём очередь "y_true" (параметр queue).
```python
# Создаём очередь y_true
channel.queue_declare(queue='y_true')
```

Далее отправляем сообщение в очередь с помощью `basic_publish()`. Параметры метода:
- exchange — определяет, в какую очередь отправляется сообщение.
Как мы знаем, в RabbitMQ сообщения не отправляются сразу в очередь, а проходят через точку обмена (exchange). Сейчас нам достаточно знать, что точку обмена по умолчанию можно определить, указав пустую строку.
- routing_key — указывает имя очереди.
- body — тело самого сообщения, которое мы хотим поместить в очередь.

```python
# Публикуем сообщение в очередь y_true
# в body может передаваться только сериализованный объект, в том числе json
# поэтому признак, или массив фич нужно предварительно сериализовать с помощью json.dumps()
channel.basic_publish(exchange='',routing_key='y_true', body=json.dumps(y[random_row]))
```

После отправки сообщений, необходимо закрыть подключение
```python
# Закрываем подключение
connection.close()
```

Посмотреть, что в очередь было отправлено сообщение можно в веб-интерфейсе RabbitMQ на закладке Queues and Streams, ниже выбираем очередь и нажимаем Get Messages (с указанием количества сообщений). Также можно войти в контейнер и получить информацию из очереди с помощью консоли. Для этого запускаем:
```bash
# запускаем оболочку bash внутри контейнера с RabbitMQ
docker exec -it rabbitmq bash 
# указываем команду rabbitmqadmin и метод get, а также название очереди и количесвто сообщений
rabbitmqadmin get queue=y_true count=10
```


В случае, если появилась необходимость в удалении сообщение из очереди можно использовать следующие варианты:
Вариант 1: удаление внутри контейнера
```bash
rabbitmqctl purge_queue y_true
```

Вариант 2: программно с помощью библиотеки `pika`:
```python
channel.queue_purge(queue='queue_name')
```

Вариант 3: остановкой и перезапуском контейнера с брокером сообщений. Так как при запуске контейнера мы указали ключ `--rm`, все данные, создаваемые контейнером, в том числе очереди, будут удалены по завершении его работы.
```bash
docker stop rabbitmq
```

Само сообщение хранится в переменной `payload`.


Для получения сообщения из очереди используется метод basic_consume(), со следующими аргументами:
- `queue` — имя очереди;
- `on_message_callback` — функцию-обработчик очереди, которая устанавливает, какие действия должны быть произведены с полученным из очереди сообщением;
- `auto_ask` — параметр, определяющий, использовать ли режим автоматического подтверждения
Пример кода по извлечению сообщений:
```python
# Извлекаем сообщение из очереди features
# on_message_callback показывает, какую функцию вызвать при получении сообщения
channel.basic_consume(
    queue='features',
    on_message_callback=callback,
    auto_ack=True
)
print('...Ожидание сообщений, для выхода нажмите CTRL+C')
```
Если планируется слушать несколько очередей, то под кажду очередь запускаем `channel.basic_consume()` с указанием названия очереди.


При этом функция обработчик, которую мы указываем в параметре `on_message_callback` - это самописаная функция, которую мы определяем в коде и которая должна иметь конкретный состав аргументов: `ch`, `method`, `properties`, `body`
Пример такой функции: 
```python
def callback(ch, method, properties, body):
    print(f'Получен вектор признаков {body}')
```
В параметре `body` хранятся сериализованные данные, переданные отправителем. 
А с помощью атрибута `method.routing_key` мы получаем информацию из какой-очереди получено сообщение.



После настройки канала получения сообщений, настройки функций, необходимо перейти в режим ожидания сообщения с помощью метода `start_consuming()`. Этот метод работает до принудительной остановки сервиса (скрипта).
```python
# Запускаем режим ожидания прихода сообщений. Запускается после определения всех очередей, которые планируется слушать
channel.start_consuming()
```



